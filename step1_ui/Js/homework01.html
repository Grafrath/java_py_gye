<!DOCTYPE html>
<html lang="ko">
    
    <head>
        <meta charset="UTF-8">
        <title>Promise 예제</title>
    </head>
    
    <body>
        <button id="sync">동기화 확인</button>
        <button id="delay">지연식 확인</button>
        <button id="besync">비동기 확인</button>
        
        <script>
            /*
            JavaScript의 비동기 통신과 Promise

            - 자바스크립트는 요청을 보낸 뒤 응답을 기다리는 동안 페이지가 멈추지 않게 하기 위해
              비동기 통신(Asynchronous Communication)을 사용한다.
            - 주요 비동기 패턴: 콜백(callback), Promise, async/await
    
            ① 동기 처리 (즉시 실행)
            ② 지연 처리 (setTimeout)
            ③ 비동기 처리 (Promise)
            를 단계별로 비교해보려 한다
            */

           
            console.log('------------------------------------');

            /*
            즉시 실행 (동기)
            가장 기본적인 동기 실행 코드.
            실행이 즉시 완료되며, 결과가 바로 출력된다.
            */
            document.querySelector("#sync").addEventListener("click", () => {
                console.log("---- [동기 실행 시작] ----");

                const random = Math.random() >= 0.5;
                if (random) {
                    console.log("✅ 데이터를 받아왔습니다.");
                } else {
                    console.error("❌ 에러 발생");
                }

                console.log("---- [동기 실행 종료] ----\n");
            });

            console.log('------------------------------------');

            /*
            setTimeout을 사용한 지연 실행
            - 3초 후 결과를 출력하도록 설정.
            
            예상과 다른 결과
            - 기대: 3초 동안 모든 동작이 멈추길 원함.
            - 실제: 다른 버튼 클릭 시 즉시 작동함.
            - 원인: JS는 이벤트 루프 기반의 비동기 처리 구조이기 때문.
            */
           
            /*
            document.querySelector("#delay").addEventListener("click", () => {
                console.log("---- [지연 실행 시작] ----");
                console.log("3초 후 결과가 출력됩니다...");

                setTimeout(() => {
                    const random = Math.random() >= 0.5;
                    if (random) console.log("✅ 3초 후 데이터를 받아왔습니다.");
                    else console.error("❌ 3초 후 에러 발생");
                    console.log("---- [지연 실행 종료] ----\n");
                }, 3000);
            });
            */

            console.log('------------------------------------');

            /*
            Promise를 이용한 비동기 처리
            - Promise는 비동기 작업의 "성공(resolve)" 또는 "실패(reject)" 상태를 반환한다.
            - then(), catch()를 통해 결과를 처리할 수 있다.
            - 아래 예시는 5초 후에 랜덤하게 성공 또는 실패 결과를 반환한다.
           */
            document.querySelector("#besync").addEventListener("click", () => {
                console.log("---- [비동기 실행 시작] ----");
                console.log("5초 후 Promise 결과가 출력됩니다...");

                const myPromise = new Promise((resolve, reject) => {
                    const random = Math.random() >= 0.5;

                    setTimeout(() => {
                        if (random) {
                            resolve("✅ Promise가 성공했습니다.");
                        } else {
                            reject("❌ Promise가 실패했습니다.");
                        }
                    }, 5000);
                });

                myPromise
                    .then((result) => console.log(result))
                    .catch((error) => console.error(error))
                    .finally(() => console.log("---- [비동기 실행 종료] ----\n"));
            });

            /*
            async / await으로 논리적 동기 흐름 구현 시도

            자바스크립트는 단일 스레드이므로 setTimeout처럼 지연을 주더라도 
            코드 실행이 완전히 멈추는 것은 불가능하다.
            
            하지만 async/await을 사용하면, 비동기 코드임에도 불구하고
            ‘잠시 멈춘 것처럼 보이는’ 논리적 동기 흐름을 표현할 수 있을것이다.
            
            - 예상:
                ‘지연식 확인’ 버튼을 눌렀을 때, 3초 대기 중에는
                다른 버튼이 작동하지 않기를 기대함.
                
            - 실제 결과:
                코드 실행은 일시적으로 멈췄지만,
                다른 버튼 클릭 시 여전히 즉시 반응함.
            
            - 원인 분석:
                await는 함수 내부 실행만 멈출 뿐,
                브라우저의 이벤트 루프(event loop)는 계속 동작하기 때문이다.
            
            즉, 대기 중에도 다른 이벤트(클릭 등)는 자유롭게 처리된다.
            
            - 결론:
                async/await은 ‘논리적 동기 흐름’을 구현할 수 있지만,
                실제 실행을 완전히 멈출 수는 없다.
            */

            /*
            async function waitPromise(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            document.querySelector("#delay").addEventListener("click", async () => {
                console.log("---- [지연 실행 시작] ----");
                console.log("3초 대기 중... (이후 코드 실행 안 됨)");
                await waitPromise(3000);  // 이 줄에서 3초 기다림 (비동기지만 동기처럼 보임)
                
                const random = Math.random() >= 0.5;
                
                if (random) {
                    console.log("✅ 3초 후 성공!");
                } else {
                    console.error("❌ 3초 후 실패!");
                }

                console.log("---- [논리적 동기 흐름 종료] ----\n");
            });
            */


            /*
            문제:
                await로 대기하는 동안에도 다른 버튼 클릭이 즉시 반응함.

            원인:
                브라우저 이벤트 루프는 계속 작동하기 때문.

            해결 방안:
                대기 중 모든 버튼을 일시적으로 비활성화(disabled) 시켜 코드 실행이 끝날 때 다시 활성화하는 방식을 적용한다.
                이렇게 하면 사용자 입장에서는 완전히 ‘잠시 멈춘’ 것처럼 보일것이다.
            */
           
            function waitPromise(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
            
            document.querySelector("#delay").addEventListener("click", async (e) => {
                console.log("---- [지연 실행 시작] ----");
                console.log("3초 대기 중... (다른 버튼은 비활성화됨)");

                // 모든 버튼 비활성화
                disableAllButtons(true);

                await waitPromise(3000);

                const random = Math.random() >= 0.5;
                
                if (random) {
                    console.log("✅ 3초 후 데이터를 받아왔습니다.");
                } else {
                    console.error("❌ 3초 후 에러 발생");
                }

                // 버튼 다시 활성화
                disableAllButtons(false);

                console.log("---- [지연 실행 종료] ----\n");
            });

            // 버튼 비활성화/활성화 함수
            // 지연 실행 중에는 다른 버튼 클릭을 막기 위해
            // 모든 버튼을 disabled 상태로 전환하였다.
            function disableAllButtons(state) {
                document.querySelectorAll("button").forEach(btn => {
                    btn.disabled = state;
                });
            }

            /*
            학습 요약
            이번 예제를 통해 자바스크립트의 실행 구조를 다음과 같이 정리할 수 있다.
            
            ① 자바스크립트는 단일 스레드(single-thread) 기반이다.
                → 한 번에 한 가지 작업만 처리할 수 있다.
            
            ② 하지만 이벤트 루프(event loop) 구조를 통해 
            비동기적으로 여러 작업을 동시에 처리하는 것처럼 보이게 만든다.
            
            ③ setTimeout, Promise, async/await 모두 비동기 처리 방식이다.
                - setTimeout : 단순한 지연 (콜백 기반)
                - Promise : 비동기 결과를 객체로 관리
                - async/await : Promise를 동기처럼 다루는 키워드

            ④ 지연식 확인’ 버튼에서 버튼 비활성화를 적용함으로써,
            사용자가 대기 중 다른 동작을 수행하지 못하도록 제어하여
            실제 동기 실행처럼 보이게 만들 수 있었다.
            
            ※추가 개선방향:
            besync도 동작 중에는 버튼을 잠그도록 처리하거나 같은 버튼 연속 클릭 방지 처리,
            혹은 지연버튼만 잠그는등 다른 기능을 더 넣음으로써 개선할수 있을것 같다.
            */
        </script>
    </body>
    
</html>
